Also provide a writeup, in a file named readme.txt or readme.pdf, a description of the rationale for your tests, what bugs each test would direct you to if it failed, and why your tests provide sufficient evidence of the absence of bugs in your program. (Please convert writeups in other formats to PDF format.) Refer to previous discussion activities on the topics of completeness and organization of tests in your writeup. Include in your write up a brief description of what each of your team members contributed to the solution.

Collaboration wise, we split up the project into two parts, 
the theory checking and the parsing and syntax checking.
Sherry and Cheryl worked on making the Expression Tree, ReadMe, part of the Proof, and the Expression class. 
Zack and Ted worked on making the Bundle, Proof, Proof Checker, and Theorem Test. 
The idea of using a bundle was Zack’s and Ted’s brainchild,
and the implementation of an expression tree was what Sherry and Cheryl came up with.
We all collaboratively worked on debugging and troubleshooting, 
we met up and worked on the code for hours outside of class time to ensure that everything worked. 

InBinaryTreeTest, we created numerous binary trees that included &, |, =>, 
and characters to check if our binary tree correctly matched everything. 
The Binary tree does a few things, it parses strings that are first going into the expression 
class and then making them into an expression tree. It also does pattern matching for the theorems 
to make sure that the theorem can be properly matched onto everything. It also does some checking to 
make sure that certain things are legal inputs, although expression is supposed to catch most of it.
In the test PatternMatching, we specifically tested to see if one tree can be matched onto the other. 
Two of the trees can be match onto each other and the third one almost matches but not quite which is
why we assert false. This checks to see if the logic is airtight and that the correctly pattern matched
tree reflects this correctness. In the second test we test to see if the two exactly same trees are the 
same which would help us prove that BinaryTree is consistent and works properly. If this failed, then we
would know that our binary tree class did not correctly print out two trees in a consistent way. 
The testinorder checks to see that the tree is printed in the format (rotated) that we exactly want 
it to be printed in and parsed properly. These tests all work to ensure that our BinaryTree is correctly parsing 
everything that is fed into it and printing out the nodes in the correct order and location.
Inside we also have some additional test cases to ensure that a proper tree is printed from the given inputs.
A tree that is correctly printed out shows that our code is correctly parsed and confirms that the BinaryTree works.


The tests in ExpressionTest specifically tests for checking the legality of the string that the user inputs
into the program. First of all, we remove any extra spaces that exist in the string so that there are no errors 
based on space inconsistencies. There are a few glaringly illegal things such as the presence of double characters
such as “==, ||, and &&” and empty strings all of which are checked for with try and catch statements.
We also check that there are the correct number of parenthesis and that there are no illegal inputs such
as strange characters or double characters (such as ‘ab’). The tests were written in such a way that we 
wrote erroneous code and the try catch statements would be able to successfully spot all of the errors 
based on the conditions that was specified in expression. We also put a couple of test cases that were 
supposed to work to double check that legal statements were indeed legal and could be recognized as such.
We feel that theses tests are complete because it checks multiple “special” cases that could arise and we
covered a wide range of possible illegal inputs that could be fed into program. 

The tests in BundleTest include tests that check the construction of the bundle class which stores the 
information that the parser parses. The function of the bundle class is to store parsed user input. 
The constructor of the bundle class is tested in the first test case by taking checking that it takes
in things such as the getlinenumber, the theorem names, and the reference lines. 
The second one checks that the bundle doesn’t randomly equal anything except itself ((??))

The bundle class makes it easy for us to take what we parsed and create things from it, 
it’s a good way to store information. We check that our bundle class 



The tests in ProofTest 
